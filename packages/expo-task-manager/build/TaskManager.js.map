{"version":3,"file":"TaskManager.js","sourceRoot":"","sources":["../src/TaskManager.ts"],"names":[],"mappings":"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","sourcesContent":["import { NativeModulesProxy, EventEmitter } from 'expo-core';\n\ninterface TaskBody {\n  data: object,\n  error: Error | null,\n  executionInfo: {\n    eventId: string,\n    taskName: string,\n  },\n}\n\ntype Task = (body: TaskBody) => void;\n\nconst { ExpoTaskManager: TaskManager } = NativeModulesProxy;\nconst eventEmitter = new EventEmitter(TaskManager);\nconst tasks: Map<string, Task> = new Map<string, Task>();\n\nlet isRunningInGlobalScope = true;\n\nfunction _validateTaskName(taskName) {\n  if (!taskName || typeof taskName !== 'string') {\n    throw new TypeError('`taskName` must be a non-empty string.')\n  }\n}\n\nexport function defineTask(taskName: string, task: Task) {\n  if (!isRunningInGlobalScope) {\n    console.error(`TaskManager.defineTask must be called in the global scope!`);\n    return;\n  }\n  if (!taskName || typeof taskName !== 'string') {\n    console.warn(`TaskManager.defineTask: 'taskName' argument must be a non-empty string.`);\n    return;\n  }\n  if (!task || typeof task !== 'function') {\n    console.warn(`TaskManager.defineTask: 'task' argument must be a function.`);\n    return;\n  }\n  if (tasks.has(taskName)) {\n    console.warn(`TaskManager.defineTask: task '${taskName}' is already defined.`);\n    return;\n  }\n  tasks.set(taskName, task);\n}\n\nexport function isTaskDefined(taskName: string): boolean {\n  return tasks.has(taskName);\n}\n\nexport async function isTaskRegisteredAsync(taskName: string): Promise<boolean> {\n  _validateTaskName(taskName);\n  return TaskManager.isTaskRegisteredAsync(taskName);\n}\n\nexport async function getTaskOptionsAsync(taskName: string): Promise<object> {\n  _validateTaskName(taskName);\n  return TaskManager.getTaskOptionsAsync(taskName);\n}\n\nexport async function getRegisteredTasksAsync(): Promise<object> {\n  return TaskManager.getRegisteredTasksAsync();\n}\n\nexport async function unregisterTaskAsync(taskName: string): Promise<null> {\n  _validateTaskName(taskName);\n  return TaskManager.unregisterTaskAsync(taskName);\n}\n\nexport async function unregisterAllTasksAsync(): Promise<null> {\n  return TaskManager.unregisterAllTasksAsync();\n}\n\neventEmitter.addListener(TaskManager.EVENT_NAME, async ({ data, error, executionInfo }) => {\n  const { eventId, taskName } = executionInfo;\n  const task = tasks.get(taskName);\n  let result: any = null;\n\n  if (task) {\n    try {\n      // Execute JS task\n      result = await task({ data, error, executionInfo });\n    } catch (error) {\n      console.error(`Background task '${taskName}' failed:`, error);\n    } finally {\n      // Notify manager the task is finished.\n      await TaskManager.notifyTaskDidFinish(taskName, { eventId, result });\n    }\n  } else {\n    console.log(`TaskManager: task ${taskName} not found :(`);\n    // No tasks defined -> we need to notify about finish anyway.\n    await TaskManager.notifyTaskDidFinish(taskName, { eventId, result });\n    // We should also unregister such tasks automatically as the task might have been removed\n    // from the app or just renamed - in that case it needs to be registered again (with the new name).\n    await TaskManager.unregisterTaskAsync(taskName);\n  }\n});\n\n// @tsapeta: Turn off `defineTask` function right after the global scope has been executed.\n// Promise.resolve() ensures that it will be called as a microtask just after the first event loop.\nPromise.resolve().then(() => {\n  isRunningInGlobalScope = false;\n});\n"]}